// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createNewOuting = `-- name: CreateNewOuting :one
INSERT INTO outings (name, user_id, status)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateNewOutingParams struct {
	Name   string    `json:"name"`
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
}

func (q *Queries) CreateNewOuting(ctx context.Context, arg CreateNewOutingParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createNewOuting, arg.Name, arg.UserID, arg.Status)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createOrGetFriend = `-- name: CreateOrGetFriend :one
with existing_friend as (
    select id
    from friends
    where friends.user_id = $2
        and friends.outing_id = $3
        and $2 is not null
    limit 1
), inserted_friend as (
    insert into friends (name, user_id, outing_id)
    select $1,
        $2,
        $3
    where not exists (
            select 1
            from existing_friend
        )
    returning id
)
select id
from inserted_friend
union all
select id
from existing_friend
limit 1
`

type CreateOrGetFriendParams struct {
	Name     string     `json:"name"`
	UserID   *uuid.UUID `json:"user_id"`
	OutingID uuid.UUID  `json:"outing_id"`
}

func (q *Queries) CreateOrGetFriend(ctx context.Context, arg CreateOrGetFriendParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createOrGetFriend, arg.Name, arg.UserID, arg.OutingID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createSplit = `-- name: CreateSplit :one
insert into splits (friend_id, order_item_id, receipt_id, quantity)
values ($1, $2, $3, $4)
returning id
`

type CreateSplitParams struct {
	FriendID    uuid.UUID `json:"friend_id"`
	OrderItemID uuid.UUID `json:"order_item_id"`
	ReceiptID   uuid.UUID `json:"receipt_id"`
	Quantity    int32     `json:"quantity"`
}

func (q *Queries) CreateSplit(ctx context.Context, arg CreateSplitParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createSplit,
		arg.FriendID,
		arg.OrderItemID,
		arg.ReceiptID,
		arg.Quantity,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (sub, email, picture, email_verified)
VALUES ($1, $2, $3, $4) ON CONFLICT (sub) DO
UPDATE
SET email = EXCLUDED.email,
    picture = EXCLUDED.picture,
    email_verified = EXCLUDED.email_verified,
    updated_at = NOW()
RETURNING id
`

type CreateUserParams struct {
	Sub           string `json:"sub"`
	Email         string `json:"email"`
	Picture       string `json:"picture"`
	EmailVerified bool   `json:"email_verified"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Sub,
		arg.Email,
		arg.Picture,
		arg.EmailVerified,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteSplit = `-- name: DeleteSplit :exec
delete from splits
where receipt_id = $1
`

func (q *Queries) DeleteSplit(ctx context.Context, receiptID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSplit, receiptID)
	return err
}

const getCachedCloudVisionResponse = `-- name: GetCachedCloudVisionResponse :one
select response
from cloud_vision_cache
where image_hash = $1
limit 1
`

func (q *Queries) GetCachedCloudVisionResponse(ctx context.Context, imageHash string) ([]string, error) {
	row := q.db.QueryRow(ctx, getCachedCloudVisionResponse, imageHash)
	var response []string
	err := row.Scan(&response)
	return response, err
}

const getCachedGenAiResponse = `-- name: GetCachedGenAiResponse :one
select response
from genai_cache
where image_hash = $1
limit 1
`

func (q *Queries) GetCachedGenAiResponse(ctx context.Context, imageHash string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCachedGenAiResponse, imageHash)
	var response []byte
	err := row.Scan(&response)
	return response, err
}

const getFriends = `-- name: GetFriends :many
select fr.id,
    fr.name
from friends fr
    join outings o on fr.outing_id = o.id
    join receipt_images ri on o.id = ri.outing_id
    join receipts r on r.receipt_image_id = ri.id
where r.id = $1
`

type GetFriendsRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) GetFriends(ctx context.Context, id uuid.UUID) ([]GetFriendsRow, error) {
	rows, err := q.db.Query(ctx, getFriends, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsRow
	for rows.Next() {
		var i GetFriendsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendsForOuting = `-- name: GetFriendsForOuting :many
WITH unique_friends_per_receipt AS (
    SELECT r.id AS receipt_id, COUNT(DISTINCT fr.id) AS friend_count
    FROM receipts r
    JOIN order_items it ON r.id = it.receipt_id
    JOIN splits sp ON it.id = sp.order_item_id
    JOIN friends fr ON sp.friend_id = fr.id
    GROUP BY r.id
)
SELECT
    fr.name,
    (SUM(it.price * sp.quantity))::float AS subtotal,
    (r.sales_tax / uf.friend_count)::float AS tax_portion,
    (SUM(it.price * sp.quantity) + (r.sales_tax / uf.friend_count))::float AS total_owed
FROM receipts r
JOIN order_items it ON r.id = it.receipt_id
JOIN splits sp ON it.id = sp.order_item_id
JOIN friends fr ON sp.friend_id = fr.id
JOIN receipt_images ri on r.receipt_image_id = ri.id
JOIN outings ou on ri.outing_id = ou.id
JOIN unique_friends_per_receipt uf ON r.id = uf.receipt_id
WHERE ou.id = $1
GROUP BY fr.id, fr.name, r.sales_tax, r.id, uf.friend_count
`

type GetFriendsForOutingRow struct {
	Name       string  `json:"name"`
	Subtotal   float64 `json:"subtotal"`
	TaxPortion float64 `json:"tax_portion"`
	TotalOwed  float64 `json:"total_owed"`
}

func (q *Queries) GetFriendsForOuting(ctx context.Context, id uuid.UUID) ([]GetFriendsForOutingRow, error) {
	rows, err := q.db.Query(ctx, getFriendsForOuting, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFriendsForOutingRow
	for rows.Next() {
		var i GetFriendsForOutingRow
		if err := rows.Scan(
			&i.Name,
			&i.Subtotal,
			&i.TaxPortion,
			&i.TotalOwed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutingForReceipt = `-- name: GetOutingForReceipt :one
select o.id
from outings o
    join receipt_images ri on o.id = ri.outing_id
    join receipts r on ri.id = r.receipt_image_id
where r.id = $1
`

func (q *Queries) GetOutingForReceipt(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getOutingForReceipt, id)
	err := row.Scan(&id)
	return id, err
}

const getOutings = `-- name: GetOutings :many
SELECT o.id,
    o.name,
    o.created_at,
    o.status,
    COALESCE(f.friends, '[]') AS friends,
    COALESCE(r.total_receipts, 0) AS total_receipts
FROM outings o
    LEFT JOIN LATERAL (
        SELECT json_agg(json_build_object('id', fr.id, 'name', fr.name)) AS friends
        FROM friends fr
        WHERE fr.outing_id = o.id
    ) f ON true
    LEFT JOIN LATERAL (
        SELECT COUNT(DISTINCT ri.id) AS total_receipts
        FROM receipt_images ri
        WHERE ri.outing_id = o.id
    ) r ON true
`

type GetOutingsRow struct {
	ID            uuid.UUID          `json:"id"`
	Name          string             `json:"name"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	Status        string             `json:"status"`
	Friends       []byte             `json:"friends"`
	TotalReceipts int64              `json:"total_receipts"`
}

func (q *Queries) GetOutings(ctx context.Context) ([]GetOutingsRow, error) {
	rows, err := q.db.Query(ctx, getOutings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOutingsRow
	for rows.Next() {
		var i GetOutingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.Status,
			&i.Friends,
			&i.TotalReceipts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReceipt = `-- name: GetReceipt :one
SELECT r.id,
    r.total,
    r.restaurant,
    r.address,
    r.opened,
    r.order_number,
    r.order_type,
    r.payment_tip,
    r.payment_amount_paid,
    r.table_number,
    r.copy,
    r.server,
    r.sales_tax,
    ri.bucket,
    ri.key,
    COALESCE(oi.items, '[]') AS items,
    COALESCE(of.fees, '[]') AS fees,
    COALESCE(spl.splits, '[]') AS splits
FROM receipt_images ri
    JOIN receipts r ON ri.id = r.receipt_image_id
    LEFT JOIN (
        SELECT receipt_id,
            json_agg(oi.*) AS items
        FROM order_items oi
        GROUP BY receipt_id
    ) oi ON r.id = oi.receipt_id
    LEFT JOIN (
        SELECT receipt_id,
            json_agg(of.*) AS fees
        FROM other_fees of
        GROUP BY receipt_id
    ) of ON r.id = of.receipt_id
    LEFT JOIN (
        SELECT receipt_id,
            json_agg(
                json_build_object(
                    'id',
                    sp.id,
                    'friend_id',
                    sp.friend_id,
                    'order_item_id',
                    sp.order_item_id
                )
            ) AS splits
        FROM splits sp
        GROUP BY receipt_id
    ) spl ON r.id = spl.receipt_id
WHERE r.id = $1
LIMIT 1
`

type GetReceiptRow struct {
	ID                uuid.UUID       `json:"id"`
	Total             sql.NullFloat64 `json:"total"`
	Restaurant        string          `json:"restaurant"`
	Address           string          `json:"address"`
	Opened            time.Time       `json:"opened"`
	OrderNumber       string          `json:"order_number"`
	OrderType         string          `json:"order_type"`
	PaymentTip        sql.NullFloat64 `json:"payment_tip"`
	PaymentAmountPaid sql.NullFloat64 `json:"payment_amount_paid"`
	TableNumber       string          `json:"table_number"`
	Copy              string          `json:"copy"`
	Server            string          `json:"server"`
	SalesTax          sql.NullFloat64 `json:"sales_tax"`
	Bucket            string          `json:"bucket"`
	Key               string          `json:"key"`
	Items             []byte          `json:"items"`
	Fees              []byte          `json:"fees"`
	Splits            []byte          `json:"splits"`
}

func (q *Queries) GetReceipt(ctx context.Context, id uuid.UUID) (GetReceiptRow, error) {
	row := q.db.QueryRow(ctx, getReceipt, id)
	var i GetReceiptRow
	err := row.Scan(
		&i.ID,
		&i.Total,
		&i.Restaurant,
		&i.Address,
		&i.Opened,
		&i.OrderNumber,
		&i.OrderType,
		&i.PaymentTip,
		&i.PaymentAmountPaid,
		&i.TableNumber,
		&i.Copy,
		&i.Server,
		&i.SalesTax,
		&i.Bucket,
		&i.Key,
		&i.Items,
		&i.Fees,
		&i.Splits,
	)
	return i, err
}

const getReceiptByHash = `-- name: GetReceiptByHash :one
SELECT ri.id AS receipt_image_id,
    ri.hash,
    ri.bucket,
    ri.key,
    ri.raw_text,
    ri.file_name,
    ri.outing_id,
    COALESCE(oi.items, '[]') AS items,
    COALESCE(of.fees, '[]') AS fees
FROM receipt_images ri
    JOIN receipts r ON ri.id = r.receipt_image_id
    LEFT JOIN (
        SELECT receipt_id,
            json_agg(oi.*) AS items
        FROM order_items oi
        GROUP BY receipt_id
    ) oi ON r.id = oi.receipt_id
    LEFT JOIN (
        SELECT receipt_id,
            json_agg(of.*) AS fees
        FROM other_fees of
        GROUP BY receipt_id
    ) of ON r.id = of.receipt_id
WHERE ri.hash = $1
LIMIT 1
`

type GetReceiptByHashRow struct {
	ReceiptImageID uuid.UUID `json:"receipt_image_id"`
	Hash           string    `json:"hash"`
	Bucket         string    `json:"bucket"`
	Key            string    `json:"key"`
	RawText        string    `json:"raw_text"`
	FileName       string    `json:"file_name"`
	OutingID       uuid.UUID `json:"outing_id"`
	Items          []byte    `json:"items"`
	Fees           []byte    `json:"fees"`
}

func (q *Queries) GetReceiptByHash(ctx context.Context, hash string) (GetReceiptByHashRow, error) {
	row := q.db.QueryRow(ctx, getReceiptByHash, hash)
	var i GetReceiptByHashRow
	err := row.Scan(
		&i.ReceiptImageID,
		&i.Hash,
		&i.Bucket,
		&i.Key,
		&i.RawText,
		&i.FileName,
		&i.OutingID,
		&i.Items,
		&i.Fees,
	)
	return i, err
}

const getReceiptImage = `-- name: GetReceiptImage :one
select ri.bucket,
    ri.key
from receipt_images ri
    join receipts r on ri.id = r.receipt_image_id
where r.id = $1
limit 1
`

type GetReceiptImageRow struct {
	Bucket string `json:"bucket"`
	Key    string `json:"key"`
}

func (q *Queries) GetReceiptImage(ctx context.Context, id uuid.UUID) (GetReceiptImageRow, error) {
	row := q.db.QueryRow(ctx, getReceiptImage, id)
	var i GetReceiptImageRow
	err := row.Scan(&i.Bucket, &i.Key)
	return i, err
}

const getReceiptsForOuting = `-- name: GetReceiptsForOuting :many
SELECT r.restaurant,
    COUNT(oi.id) AS order_count,
    r.total,
    r.id
FROM receipts r
    JOIN order_items oi ON r.id = oi.receipt_id
    JOIN receipt_images ri ON r.receipt_image_id = ri.id
WHERE ri.outing_id = $1
GROUP BY r.id
`

type GetReceiptsForOutingRow struct {
	Restaurant string          `json:"restaurant"`
	OrderCount int64           `json:"order_count"`
	Total      sql.NullFloat64 `json:"total"`
	ID         uuid.UUID       `json:"id"`
}

func (q *Queries) GetReceiptsForOuting(ctx context.Context, outingID uuid.UUID) ([]GetReceiptsForOutingRow, error) {
	rows, err := q.db.Query(ctx, getReceiptsForOuting, outingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReceiptsForOutingRow
	for rows.Next() {
		var i GetReceiptsForOutingRow
		if err := rows.Scan(
			&i.Restaurant,
			&i.OrderCount,
			&i.Total,
			&i.ID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBySub = `-- name: GetUserBySub :one
select id,
    sub,
    email,
    picture,
    created_at,
    updated_at
from users
where sub = $1
`

type GetUserBySubRow struct {
	ID        uuid.UUID          `json:"id"`
	Sub       string             `json:"sub"`
	Email     string             `json:"email"`
	Picture   string             `json:"picture"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserBySub(ctx context.Context, sub string) (GetUserBySubRow, error) {
	row := q.db.QueryRow(ctx, getUserBySub, sub)
	var i GetUserBySubRow
	err := row.Scan(
		&i.ID,
		&i.Sub,
		&i.Email,
		&i.Picture,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCachedCloudVisionResponse = `-- name: InsertCachedCloudVisionResponse :one
insert into cloud_vision_cache (image_hash, response)
values ($1, $2)
returning id
`

type InsertCachedCloudVisionResponseParams struct {
	ImageHash string   `json:"image_hash"`
	Response  []string `json:"response"`
}

func (q *Queries) InsertCachedCloudVisionResponse(ctx context.Context, arg InsertCachedCloudVisionResponseParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertCachedCloudVisionResponse, arg.ImageHash, arg.Response)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertCachedGenAiResponse = `-- name: InsertCachedGenAiResponse :one
insert into genai_cache (image_hash, response)
values ($1, $2)
returning id
`

type InsertCachedGenAiResponseParams struct {
	ImageHash string `json:"image_hash"`
	Response  []byte `json:"response"`
}

func (q *Queries) InsertCachedGenAiResponse(ctx context.Context, arg InsertCachedGenAiResponseParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertCachedGenAiResponse, arg.ImageHash, arg.Response)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertOrderItem = `-- name: InsertOrderItem :exec
INSERT INTO order_items (receipt_id, name, price, quantity)
VALUES ($1, $2, $3, $4)
`

type InsertOrderItemParams struct {
	ReceiptID uuid.UUID       `json:"receipt_id"`
	Name      string          `json:"name"`
	Price     sql.NullFloat64 `json:"price"`
	Quantity  int32           `json:"quantity"`
}

func (q *Queries) InsertOrderItem(ctx context.Context, arg InsertOrderItemParams) error {
	_, err := q.db.Exec(ctx, insertOrderItem,
		arg.ReceiptID,
		arg.Name,
		arg.Price,
		arg.Quantity,
	)
	return err
}

const insertOtherFee = `-- name: InsertOtherFee :exec
INSERT INTO other_fees (receipt_id, name, price)
VALUES ($1, $2, $3)
`

type InsertOtherFeeParams struct {
	ReceiptID uuid.UUID       `json:"receipt_id"`
	Name      string          `json:"name"`
	Price     sql.NullFloat64 `json:"price"`
}

func (q *Queries) InsertOtherFee(ctx context.Context, arg InsertOtherFeeParams) error {
	_, err := q.db.Exec(ctx, insertOtherFee, arg.ReceiptID, arg.Name, arg.Price)
	return err
}

const insertReceipt = `-- name: InsertReceipt :one
INSERT INTO receipts (
        receipt_image_id,
        restaurant,
        address,
        opened,
        order_number,
        order_type,
        table_number,
        server,
        subtotal,
        sales_tax,
        total,
        copy
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12
    )
RETURNING id
`

type InsertReceiptParams struct {
	ReceiptImageID uuid.UUID       `json:"receipt_image_id"`
	Restaurant     string          `json:"restaurant"`
	Address        string          `json:"address"`
	Opened         time.Time       `json:"opened"`
	OrderNumber    string          `json:"order_number"`
	OrderType      string          `json:"order_type"`
	TableNumber    string          `json:"table_number"`
	Server         string          `json:"server"`
	Subtotal       sql.NullFloat64 `json:"subtotal"`
	SalesTax       sql.NullFloat64 `json:"sales_tax"`
	Total          sql.NullFloat64 `json:"total"`
	Copy           string          `json:"copy"`
}

func (q *Queries) InsertReceipt(ctx context.Context, arg InsertReceiptParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertReceipt,
		arg.ReceiptImageID,
		arg.Restaurant,
		arg.Address,
		arg.Opened,
		arg.OrderNumber,
		arg.OrderType,
		arg.TableNumber,
		arg.Server,
		arg.Subtotal,
		arg.SalesTax,
		arg.Total,
		arg.Copy,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertReceiptImage = `-- name: InsertReceiptImage :one
INSERT INTO receipt_images (
        hash,
        bucket,
        key,
        raw_text,
        file_name,
        outing_id
    )
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type InsertReceiptImageParams struct {
	Hash     string    `json:"hash"`
	Bucket   string    `json:"bucket"`
	Key      string    `json:"key"`
	RawText  string    `json:"raw_text"`
	FileName string    `json:"file_name"`
	OutingID uuid.UUID `json:"outing_id"`
}

func (q *Queries) InsertReceiptImage(ctx context.Context, arg InsertReceiptImageParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, insertReceiptImage,
		arg.Hash,
		arg.Bucket,
		arg.Key,
		arg.RawText,
		arg.FileName,
		arg.OutingID,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
